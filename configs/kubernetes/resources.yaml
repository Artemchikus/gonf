Resources:
  -
    Name: "Pod"
    Description: "Базовый объект, который используется для запуска контейнеров на Node'ах. Контейнеры, создаюся с помощью Dockerfile'ов и не только. Внутри одного Pod'а может находится несколько контейнеров, которые будут иметь общий доступ к таким ресурсам, как Volume'ы и сетевой стек, что удобно в некоторых случаях, но в основном внутри одного Pod'а находится один основной контейнер и может еще контейнер для сбора метрик. В ручную контейнеры в Kubernetes никто не создает"
  -
    Name: "ReplicaSet"
    Description: "Объект, являющийся ReplicationController'ом маминой подруги и в будущем должен его полностью заменить, предназначен для автоматичегкого управления Pod'ами, а именно он позволяет поддерживать заданное админом количество Pod'ов не смотря ни на что, то есть ReplicaSet автоматически поднимет заданное количество Pod'ов и при отказе одного из них создаст недостающий Pod, а неисправный остановит и удалит. Pod'ы выбираются в ReplicaSet с помощью меток, как и в ReplicationController, но у ReplicaSet расширенный функционал селектора меток (единственное отличие)."
  -
    Name: "ReplicationController"
    Description: "Объект, предназначен для автоматичегкого управления Pod'ами, является клоном ReplicaSet, но хуже, так что лучше использовать ReplicaSet."
  -
    Name: "Deployment"
    Description: "Объект преназанченный для равертывания и обновления ReplicaSet, позволяет настроить процесс равертывания Pod'ов, а именно сколько Pod'ов могут разворачиваться одноверменно, сколько Pod'ов могут быть недоступны одновеременно, после чего можно например изменить образ Pod'а в манифесте и Deployment автоматически будет удалять по одному сатрому поду и плавно заменять их новыми (при одной из настроек), тем самым доступность приложения не падает."
  -
    Name: "Service"
    Description: "Объект пренаначенный для предоставления общего IP адресса нескольким одинаковым(имеют одинаковый набор меток) Pod'ам. Например вы (или предназначенные для этого ресурсы) для увеличения доступности распихали ваши Pod'ы по Node'ам в разных концах света, естественно каждый под работает на рзных портах разных Node, Service в свою очередь предоставляет одну точку входа для всех запросов, а потом равномерно распределяет их между Pod'ами, что удобно, ведь это работает даже при обмене запросов внутри Cluster'a. Также если ваш Pod упадет, есть вероятность, что он восстановится уже на другой Node, IP адресс изменится, но Service его не потеряет."
    Types:
      -
        Name: "LoadBalancer"
        Description: "Тип Service, при котором Pod'ы подключенные к сервису доступны по единому IP адресу извне, обычно предоставляется облачными провайдерами, но есть бесплатное решение для голого железа под названием MetalLB. Самый крутой тип для публичных сервисов, ведь можно самостоятельно настраивать балансировку нагрузки между Pod'ами."
      -
        Name: "NodePort"
        Description: "Тип Service, при котором Pod'ы подключенные к сервису доступны по единому порту IP адреса любой Node'ы, то есть доступ к Service осуществляется, черезе IP адрес любой Node'ы + забинженный единый порт. Доступ извне как не трудно догадаться присутствует."
      -
        Name: "ClusterIP"
        Description: "Тип Service, при котором Pod'ы подключенные к сервису доступны по единому IP только внутри Cluster'а. Если не хочется все плюшки Service, но без доступа к Pod'ам извне."
      -
        Name: "ExternalName"
        Description: "Тип Service, при котором DNS имя уже созданного Service на DNS сервере Kubernetes мапится на другое DNS имя, так что при запросе на DNS сервер по новому DNS имени, запрос перенапрвится по старому имени. Честно говоря сам не заню для чего это используется."
  -
    Name: "Node"
    Description: "Объект представляющий из себя сервер, на которм будут запускаться ваши Pod'ы. Обычно должно быть как минимум 3 Master Node'а (узлы управления кластером, на них например хостится API server) и 3+ Worker Node'ов (узлы, на которых лежат рабочие Pod'ы)."
  -
    Name: "ConfigMap"
    Description: "Объект, который позволяет разделять конфигурационные файлы и контейнеры с приложениями, избавляя от необходимости упаковывать конфиги в docker-образ. ConfigMap можно монтировать в файловую систему Pod'а, а также использовать значения ConfigMap для задания ENV переменных и аргументов в манифестах Pod'ов."
  -
    Name: "Secret"
    Description: "Объект, похожий на ConfigMap, но предназначеный для хранения конфиденциальной информации, такой как пароли, OAuth-токены или ssh-ключи. Та же функциональность, но все значения ключей кодируются в base64."
  -
    Name: "StatefulSet"
    Description: "Объект, который используется для управления приложениями и отслеживания их состояния. Другими словами это ReplicaSet, но если Pod, созданный ReplicaSet при удалении и создании получает новое DNS-имя, IP-адрес и теряет все, что было сохранено в файловую систему Pod'а, то при использовании StatefulSet после перезапука Pod'а все это сохраняется, а также PersistentVolumeClaim, ведь нормально использовать PersistentVolumeClaim для каждого Pod'а в ReplicaSet не получится."
  -
    Name: "DaemonSet"
    Description: "Объект, который используется для ращмещения Pod'ов по Node'ам, гарантирует что на Node'ах с соответсвующими метками будут размещены данные Pod'ы. Например для сбора метрик Node'ов."
  -
    Name: "HorizontalPodAutoscaler"
    Description: "Объект предназанченный для автоматического масштабирования количества Pod'ов, в зависимотси от потребляемых ими ресурсов(CPU или Memory) или кастомных метрик. Не будет работать, если на API-сервер не будут приходить метрики, поэтому неодходимо реализовать сборщика и приемщика этих метрик, одна из реализаций cAdvizor + Metrics Server. Для кастомных метрик можно использовать NodeExporter + Promtheus + Kube-State-Metrics + Prometheus Adapter."
  -
    Name: "PersistentVolume"
    Description: "Объект прдставляющий собой постоянный том (Persistent Volume), который можно монтировать в Pod'ы с помощью PersistentVolumeClaim, тем самым сохраняя информацию после отказа или перерзапуска Pod'a."
  -
    Name: "PersistentVolumeClaim"
    Description: "Объект, являющийся заявкой на PersistentVolume, который помогает абстрагировать програмиста, которму просто нужно хранилище данных от админа, которыми этими хранилищами ворочает. Простыми словами програмист составляет манифест PersistentVolumeClaim, что ему нужно хранилище на 50Гб, и ему автоматически предоставляется PersistentVolume, соответсвующее критериям или лучше (например на 100Гб, если на 50Гб нет). Если свободного PersistentVolume нет, то Pod будет находится в режиме ожидания, но есть PersistentVolume Provisioners, как от облачных вендоров, так и от сообщества, реализующие автоматическое создание PersistentVolume по PersistentVolumeClaim, например GlusterFS + Heketi."
  -
    Name: "StorageClass"
    Description: "Объект, который предоставляет возможность разделить хранилища на классы с определенными параметрами, на основе которых потом будут составляться PersistentVolume. StorageClass может предоставляться облачным вендором, а также его может создать пользователь, для описания своего собственного хранилища."
  -
    Name: "Ingress"
    Description: "Объект, который предоставляет возможность доступа к разным сервисам внутри кластера по одному DNS имени, например my-site.com/frontend будет перенаправлять все запросы в frontend Pod'ы, а my-site.com/backend будет перенаправлять все запросы в backend Pod'ы, что удобно когда у вас много микросервисов. Не работает без Ingress Controller, например Ingress-Nginx, и без настроенного LoadBalancer."
  -
    Name: "IngressClass"
    Description: "Объект, который представляет собой аналог StorageClass для Ingress Controller'ов, позволяет связывать объекты Ingress c Ingress Controler'ами, а также передавать дополнительные параметры конфигурации Ingress'ам."
  -
    Name: "Namespace"
    Description: "Объект, который предоставляют область имен для ресурсов для разделения ресурсов Cluster'a между пользователями(не только User'ы, но и процессы внутри Pod'ов например) для удобства и кончено безопасности, так как большинство ресурсов видят только в пределах своего Namespace, если конечно не обращаются к общему для все кластера DNS серверу. Также удобно, что при удалении Namespace все ресурсы, которые в нем находились тоже удалятся."
  -
    Name: "ServiceAccount"
    Description: "Объект, который позволяет предоставить идентификатор, используя который ресурсы Cluster'а, а точнее процессы внутри этих ресурсов, могут быть аутенифицированы и авторизованы для выполнения запросов к API-серверу Kubernetes. Их можно связывать с Role'ами для предоставления различных прав при общении с API-сервером. С точки зрения абстракции похож на StorageClass и IngressClass."
  -
    Name: "Role"
    Description: "Объект, который описывает набор прав на ресурсы Cluster'а, но в пределах Namespace, в котором находится ресурс."
  -
    Name: "RoleBinding"
    Description: "Объект, который связывает Role и ресурс Cluster'а, то есть у нескольких ресурсов может быть одна Role. Если связать ClusterRole через RoleBinding, то ресурс получит права только внутри Namespace, что удобно ведь можно создать одну общую ClusterRole, которую можно свзязывать RoleBinding в нескоьких Namespace, вместо создания Role в каждом из этих Namespace'ов."
  -
    Name: "ClusterRole"
    Description: "Объект, который описывает набор прав на ресурсы Cluster'а, но в отличии от Role, как в родном Namespace, так и по всему Claster'у."
  -
    Name: "ClusterRoleBinding"
    Description: "Объект, который аналогично RoleBinding, связывает CluserRole и ресурс Cluster'а."
  -
    Name: "LimitRange"
    Description: "Объект, который отслеживает выставление значений реквестов/лимитов по ресурсам для всех подов в немспейсе. Используется для того, чтобы отдельно взятый Pod не хапал CPU или Memory больше положенного админом."
  -
    Name: "ResourceQuota"
    Description: "Объект, который ограничивает суммарное количество ресурсов, которое могут запросить все ресурсы в Namespace'е. Используется для того, чтобы совокупность Pod'ов в Namespace не хапала больше чем положенного (отдельновзятый Pod никак не контролируется, он может один хоть все место занять в Namespace'е, главное чтоб не больше ResourceQuota)."
  -
    Name: "Job"
    Description: "Объект, который создаёт Pod для выполнения разовой задачи. Если запуск задачи завершается с ошибкой, Job перезапускает поды до успешного выполнения или до истечения таймаутов. Когда задача выполнена, Job считается завершённым и больше никогда в кластере не запускается."
  -
    Name: "CronJob"
    Description: "Объект, который по расписанию создает Job'ы."
  -
    Name: "Endpoints"
    Description: "Объект, который связывает Pod'ы и Service'ы, содержит в себе список IP адресов Pod'ов которые принадлежат Service'у. Обычно создается автоматически, но можно созвть кастомный Endpoints."
  -
    Name: "EndprointsSlice"
    Descriptionn: "Объект, содержащий в себе сисок различных Endpoints'ов, для более удобного наблюдения за всеми Endpoints'ами в Cluster'е."
  -
    Name: "CSIDriver"
    Description: "Объект, который представляет собой драйвер связывающий Container Storage Interface (унифицированный интерфейс, который описывает взаимодействие системы управления контейнерами и специального драйвера) и Систему Хранения Данных, которую может представлять облачный вендор, тогда CSIDriver уже написан за вас, или ваша собственная Система Хранения Данных, но в таком случае нужно будет написать свой CSIDriver, в таком случае нужно будет написать Node Plugin (отвечает за монтирование Volume'ов и за операции на них) и Controller Plugin (cоздает или удаляет Volume'ы, назначает права доступа и т. д.). Next Big Thing Kubernetes."
  -
    Name: "VolumeAttachment"
    Description: "Объект, который описывает информацию, относящуюся к монтированию и размонтированию Volume при использовании Pod'а. В зависимости от статуса VolumeAttachment External-attacher выполняет операции монтирования и размонтирования Volume'ов. Другими словами хранит в себе инфу дали ли PV по PVC. Обычно создается автоматически."
  -
    Name: "CSINode"
    Description: "Объект, который хранит информацию о Node в Cluster'е для Container Storage Interface. Container Storage Interface будет работать только с теми Node'ами, которые есть в списке CSINode."
  -
    Name: "CSIStorageCapasity"
    Description: "Объект, который содержит информацию о емкости для одного StorageClass и определяет, какие Node'ы имеют доступ к этому StorageClass. Обычно создается CSIDriver'ом."
  -
    Name: "ControllerRevision"
    Description: "Объект, который хранит в себе снимок состояния при обновлении Deployment, DaemonSet и StatefulSet, чтобы можно было откатиться к старой версии. Обычно создается контроллерами стоящими за этими ресурсами."
  -
    Name: "CustomResourceDefinition"
    Description: "Объект, который позволяет добавлять новые типы ресурсов в API Kubernetes, не изменяя исходный код Kubernetes или создавая собственный сервер API, если ресурсов из коробки не хватает."
  -
    Name: "Event"
    Description: "Объект, который показывает, что происходит в кластере при изменении состояния или ошибках, вызванных другими ресурсами системы. Создается автоматически всеми ресурсами Cluster'a."
  -
    Name: "MutatingWebhookConfiguration"
    Description: "Объект, который описывает конфигурацию и прием webhook'ов, которые принимают или отклоняют и могут изменять объект. С помощью MutatingWebhookConfiguration вы теоретически можете прослушивать и изменять запросы на изменеие объектов, обрабатываемые ApiServer."
  -
    Name: "ValidatingWebhookConfiguration"
    Description: "Объект, который описывает конфигурацию и прием webhook'ов, которые принимают или отклоняют объект без его изменения. С помощью ValidatingWebhookConfiguration вы теоретически можете прослушивать и изменять запросы на получение информации об объектах, обрабатываемые ApiServer."
  -
    Name: "PodTemplate"
    Description: "Объект, который описывает шаблон Pod'а. Таким образом можно созать один PodTemplate, а потом использовать его в ресурсах разворачивающих Pod'ы (Deployment и т. д.), чтобы каждый раз не писать одну и то же описание Pod'а."
  -
    Name: "PodDistributionBudget"
    Description: "Объект, который задает количество Pod'ов определенных меток, которые должны продолжать работать даже при выходе Node'ы из строя. В основном используется при миграции Pod'ов с старой Node'ы на новую (с помощью команды Drain, которая помечает Node'у как вышедшую из строя), чтобы сохранялась доступность приложений, если не создавать PodDistributionBudget то сначала все Pod'ы старой Node'ы остановятся, и только потом перенесутся, что сделает приложения работающие на данных Pod'ах временно недоступными."
  -
    Name: "PriorityClass"
    Description: "Объект, который связывает приоритетность Pod'a с самим Pod'ом. Схож со StorageClass и т. д. и используется для удобного деления Pod'ов на группы по приоритетам, а также для безопасности ведь Джуны могут ставить своим Pod'ам высокие приоритеты, тем самым например вытесняя все нужные Pod'ы с высокопроизводительных Node'ов. Чем выше приоритет Pod'а тем дальше он в очереди на вытеснение (если на Node нет свободного места, а туда планировщиком назначен Pod, то какой-то старый Pod останавливается и переносится на другую Node'у) с Node'ы."
  -
    Name: "PodSecurityPolicy"
    Description: "Объект, который обеспечивают точную авторизацию создания и обновлений Pod'ов, другими словами PodSecurityPolicy определяют набор условий, с которыми должен работать модуль, чтобы быть принятым в систему, а также значения по умолчанию для связанных полей. Используется для обеспечения безопасности, но устареет уже в версии 1.25 Kubernetes, кго заменит Pod Security Admission"
  -
    Name: "APIService"
    Description: "Объект, который позволяет расширить API-сервер Kubernetes дополнительными API, которые не являются частью основных API Kubernetes. Например для работы HorizontalPodAutoscaler нужно расширение для API-сервера Kubernetes под названием custom-metrics-apiserver, которое создает prometheus-adapter или вы (см. офицальную документацию на английском). Удобный фреймворк - Kubebuilder."
  -
    Name: "CretificateSigningRrequest"
    Description: "Объект, который обеспечивают механизм получения сертификатов x509 путем подачи запроса на подписание сертификата, его асинхронного одобрения и выдачи. Пользователь генирует закрытый ключ RSA (обычно с помощью openssl), далее генерирует (с помощью файла конфигурации и openssl) запрос на подпись сертификата (CSR, как и название ресурса), псоле чего CSR отправляется админам, которые на его основе создают (примерно в 3 шага) ресурс CretificateSigningRrequest, который будет использоваться для аутентификации запросов, который пользователь отправит на сервер API."
  -
    Name: "FlowSchema"
    Description: "Объект, который сопоставляет некоторые входящие запросы приходящие на API-сервер Kubernetes с PriorityLevelConfiguration. Запрос, приходящий на API-сервер, сначала оценивается на соответствие одной из схем потоков (FlowSchema), после чего FlowSchema назначает запросу уровень приоритета, что помогает бороться с ситуациями, когда низкоприоритетный трафик душит критически важные вызовы. Трафик делится по потокам (например запросы из одного источника в один поток) и уровням приоритета (ограничивать только запросы с определенным уровнем приоритета)."
  -
    Name: "PriorityLevelConfiguration"
    Description: "Объект, который определяет конфигурацию уровня приоритета, например долю параллелизма или стратегию обработки очереди запросов. Если FlowSchema просто сортировала запросы, то PriorityLevelConfiguration уже регулирует трафик внутри определенного потока (FlowSchema)."
  -
    Name: "Lease"
    Description: "Объект, предназанченный для определения живости Node'ы. Обычно создается Kubelet, после чего обновляется каждые 10 секунд (а именно поле acquireTime), если объект обновился неудачно, то с Node'ой какая-то проблема. Люди ворде как его не создают."
  -
    Name: "SubjectAccessReview"
    Description: "Объект, который проверяет, может ли пользователь или группа выполнить действие. После отпраки yaml на API-сервер Kubernetes, поле status SubjectAccessReview будет указывать, может ли пользователь или группа выполнить действие."
  -
    Name: "LocalSubjectAccessReview"
    Description: "Объект, который проверяет, может ли пользователь или группа выполнять действие в данном Namespace. Принцип работы как у SubjectAccessReview, но только проверка осуществляется внутри одного Namespace."
  -
    Name: "SelfSubjectAccessReview"
    Description: "Объект, который проверяет, может ли пользователь (или ресурс), отправивщий yaml файл выполнять действие в данном Namespace или вообще. Принцип работы как у SubjectAccessReview, но только проверка осуществляется для \"самого себя\"."
  -
    Name: "SelfSubjectRulesReview"
    Description: "Объект, который возвращает набор действий, которые пользователь может выполнять в Namespace. Принцип работы как у SubjectAccessReview, но только осуществляется не проверка, а просто возвращаются (в status.resourceRules.verbs) разрешенные действия для User'а."
  -
    Name: "RuntimeClass"
    Description: "Объект, с помощью которого можно выбрать среду выполнения контейнера. Если считаешь, что дефолтная среда выполнения не достаточно безопасная. Хайповая среда выполнения - gVisor."
  -
    Name: "TokenRequest"
    Description: "Объект, который запрашивает токен для данного ServiceAccount. Принцип работы схож с SubjectAccessReview, в поле status будет информация о выдаче токена (сам токен и на какой период времени)."
  -
    Name: "TokenReview"
    Description: "Объект, который проверяет принадлежит ли данный токен данному User'у и ServiceAccount'у. Принцип работы схож с SubjectAccessReview, в поле status будет информация связан ли токен, а также инвормация о User'е или ServiceAccount'е. Придуман, чтоб Pod'ы друг друга аутентифицировали."
  -
    Name: "NetworkPolicy"
    Description: "Объект, который описывает, какой сетевой трафик разрешен для данного набора Pod'ов. Если быть точным, то в NetworkPolicy блокируются IP-адреса, типы протоколов, порты, Nammespace'ы и Pod'ы, на ктоторые Pod может слать запросы, и от которых Pod может получать запросы. По дефолту Pod может отправлять запросы кому хочет и получать запросы от кого хочет."
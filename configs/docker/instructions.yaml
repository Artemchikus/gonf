Instructions:
  -
    Name: "FROM"
    Description: "\tЗадает базовый образ для последующих инструкций. Можно использовать любой работающий образ, проще всего начать с загрузки образа из публичного репозитория. Пустой образ - \"scratch\". Обычно является первой инструкцией, но может идти после ARG, чтобы например использовать имя образа из аргументов комады сборки контейнера (${имя аргумента}). Также FROM может использоваться несколько раз внутри одного Dockerfile, например для уменьшения размера конченого контейнера.
    \n\tШаблоны ввода:
    \n\t\t• <образ> 
    \n\t\t• <образ>:<тэг> (тэг - конкретная версия образа, по умолчанию \"latest\") 
    \n\t\t• <образ>@<дайджест> (дайджест - хэш образа, если в образе что-то поменяют, то и хэш изменится) 
    \n\t\t• <образ>:<тэг>@<дайджест> (пример - ubuntu:20.04@sha256:8bce67040cd0ae39e0beb55bcb976a824d9966d2ac8d2e4bf6119b45505cee6)
    \n\tТакже после любого из шаблонов можно добавить инструкцию \"AS <имя>\" для изменения имени образа."
    PlaceHolder: "<образ>"
    HintText: "Обязательное поле"
  -
    Name: "RUN"
    Description: "\tВыполняет любые команды в новом слое поверх текущего образа и делает коммит результата. Как можно понять создает слой с каждой новой инструкцией. Полученный после коммита образ будет использован для следующего шага в Dockerfile.\n\tШаблоны ввода:
    \n\t\t• <команда>; <команда> (команды базовой оболочки Linux или Windows)
    \n\t\t• [\"исполняемый файл\", \"параметры\"...] (Исполнение файла с параметрами, если нужна команда не базовой оболочки)
    \n\tЕсть поддержка исполнения нескольких команд внутри одного RUN, перенося их на следующую строку через \"\\\" и <Enter> естественно, и это хорошая практика, так как в таком случае не создаются новые слои. Если надо сменить базовую оболочку предварительно используйте инструкцию SHELL."
    IsMany: true
    PlaceHolder: "<команда>"
  -
    Name: "CMD"
    Description: "\tЗадает команду или исполняемый файл с парамерами по умолчанию, который(ая) будет выполнен(а) при запуске контейнера, также можно опустить исполняемый файл, но в этом случае вы должны использовать инструкцию ENTRYPOINT. RUN - работает во время сборки, CMD - при запуске.
    \n\tШаблоны ввода:
    \n\t\t• <команда> <параметры>... (команда оболочки, которая выполнится при запуске контейнера)
    \n\t\t• [\"исполняемый файл\", \"параметры\"...] (файл, который запустится с заданными параметрами при запуске контейнера)
    \n\t\t• [\"параметры\"...] (параметры запуска, которые будут переданы инструкции ENTRYPOINT)
    \n\tАргументы переданные при запуске контейнера могут переопределять параметры по умолчанию, в том числе и исполняемый файл, поэтому для обозначения исполняемого файла лучше использовать ENTRYPOINT. В Dockerfile следует задать хотя бы одну из команд CMD или ENTRYPOINT."
    PlaceHolder: "[\"<исполняемый файл>\", \"<параметры>\"...]"
  -
    Name: "LABEL"
    Description: "\tДобавляет метаданные(например размер контейнера или имя автора) с именем <ключ> и значением <значение> для образа. Раньше содавала новый слой теперь нет, так что можно не париться и добавлять новые лейблы через дублирование инструкции, в отличие от RUN, где это не приветсвуется. Если Docker встречает лейбл который уже существует, то старое значение будет заменено новым.
    \n\tШаблоны ввода:
    \n\t\t• <ключ>=\"<значение>\" (лучше все значения писать в \"\", будет меньше проблем)"
    IsMany: true
    PlaceHolder: "<ключ>=\"<значение>\""
  -
    Name: "EXPOSE"
    Description: "\tУказывает Docker что контейнер слушает определенные порты после запуска. EXPOSE не делает порты контейнера доступными для хоста, но это уже проблема оркестраторо (если кратко то проты контейнера еще нужно пробросить на порты хоста, чтобы можно было работать с приложениями внутри контейнера извне).
    \n\tШаблоны ввода:
    \n\t\t• <порт> (порт, на котором работает ваше прилодение внутри контейнера)
    \n\t\t• <port>/<protocol> (порт вместе с протоколом UDP или TCP, TCP - дефолтный)
    \n\tМожно обявлять сразу несколько протов через пробел, но EXPOSE не создает слоев, так что зачем, просто дублируем инструкцию для лучшей читаемости."
    PlaceHolder: "<порт>"
  -
    Name: "ENV"
    Description: "\tЗадает переменные окружения с именем <ключ> и значением <значение>. Эти значения будут находиться в окружении всех команд потомков Dockerfile и могут быть использованы как обычные переменные окружения. Значение будет интерпретировано для других переменных среды, поэтому символы кавычек будут удалены, если они не экранированы. Переменные окружения сохраняться и после сборки контейнера, так что если по какой-то причине этого не хочется, то можно запихнуть ENV внутрь RUN (RUN <ключ>=<значение> <команда>), где она исчезнет после выполнения команды.
    \n\tШаблоны ввода:
    \n\t\t• <ключ>=<значение> (имя и значение переменной окружения)
    \n\tМожно инициализировать в одной инструкции несколько переменных окружения, но ENV не создает слоя, так что не вижу в этом смысла, смело дублируем инструкции."
    IsMany: true
    PlaceHolder: "<ключ>=<значение>"
  -
    Name: "ADD"
    Description: "\tКопирует новые файлы, папки или удаленные файлы по URLs из <откуда> и добавляет их в файловую систему контейнера в <куда> (абсолютный, если перед <куда> есть \"/\", или относительный путь при использовании WORKDIR, , если перед <куда> нет \"/\"), СТОП но это же COPY маминой подруги. Но будь проклят тот, кто использует ее для обычного копирования локальных файлов, ведь для этого есть COPY, лучшие практики что сказать.
    \n\tШаблоны ввода:
    \n\t\t• <откуда> <куда> (<откуда> может быть URL или сжатый архив, с остальным пожалуйста к COPY)
    \n\t\t• <откуда>... <куда>/ (несколько источников файлов, также есть поддержка групповых символов (wildcards), <куда> должен быть каталогом и оканчиваться \"/\")
    \n\tADD не поддерживает аунтефикацию, с этим идем к RUN curl и тд. Если <откуда> является URL и <куда> заканчивается слешем, то имя файла берется из URL и файл скачивается в <куда>/<имя файла>. Также сам каталог <откуда> не копируется, только его содержимое. Локальный сжатый архив распакуется, а вот по URL - нет. При отсутвии <куда> он создастся. Создает новый слой, так что добавляем по-минимому."
    IsMany: true
    PlaceHolder: "<откуда> <куда>"
  -
    Name: "COPY"
    Description: "\tИнструкция COPY копирует новые файлы или каталоги из <откуда> и добавляет их в файловую систему контейнера в <куда> (абсолютный, если перед <куда> есть \"/\", или относительный путь при использовании WORKDIR, , если перед <куда> нет \"/\").
    \n\tШаблоны ввода:
    \n\t\t• <откуда> <куда> (<откуда> должен находится внутри контекста сборки, то есть не выше каталога, в котором лежит Dockerfile)
    \n\t\t• <откуда>... <куда>/ (несколько источников файлов, также есть поддержка групповых символов (wildcards), <куда> должен быть каталогом и оканчиваться \"/\")
    \n\tЕсли <откуда> - каталог, то копируется содержимое каталога, а не сам каталог. Если <куда> не заканчивается слешем, он будет рассматриваться как обычный файл и содержимое <откуда> будет записано в <куда>. При отсутвии <куда> он создастся. Создает новый слой, так что копируем по-минимому."
    IsMany: true
    PlaceHolder: "<откуда> <куда>"
  -
    Name: "ENTRYPOINT"
    Description: "\tПозволяет настроить контейнер так что бы он работал как исполняемый файл.Тот же самый функционал как у CMD, но CMD используют в основном для предачи параметров в ENTRYPOINT или для исполнения команды по умолчанию в оболочке, другими словами бинарник выбираем в ENTRYPOINT, а с помощью CMD выполняем команды. Обе инструкции выполняются во время запуска контейнера, не во время сборки.
    \n\tШаблоны ввода:
    \n\t\t• [\"<исполняемый файл>\", \"<параметры>\"...] (предпочтительная форма)
    \n\t\t• command param1 param2 (фу такую форму использовать)
    \n\tТолько последняя инструкция ENTRYPOINT из Dockerfile будет запущена, но CMD, если в ней указан исполняемый файл или команда, тоже запустится, но лучше таким не заниматься. В Dockerfile следует задать хотя бы одну из команд CMD или ENTRYPOINT. Если CMD определяется из базового образа (после FROM), установка ENTRYPOINT сбросит CMD до пустого значения."
    PlaceHolder: "[\"<исполняемый файл>\", \"<параметры>\"...]"
  -
    Name: "VOLUME"
    Description: "\tСоздает точку монтирования с заданным именем и помечает его как внешний смонтированный том из базового хоста или контейнера. Таким образом можно например сохранять данные БД, которая находится внутри контейнера в файловой системе хоста, ведь контейнер создается с ограниченным свободным местом и все внутренние данные теряются при перезапуске.
    \n\tШаблоны ввода:
    \n\t\t• [\"/<точка монтирования>\"]
    \n\t\t• /<точка монтирования> (предпочтительней)
    \n\tМожно описать несколько точек монтирования в одной инструкции, но слой не создается, так что лучше дублировать инструкцию."
    PlaceHolder: "/<точка монтирования>"
  -
    Name: "USER"
    Description: "Устанавливает имя пользователя (UID) от имени которого будет запущен образ, а также инструкции RUN, CMD и ENTRYPOINT содержащиеся в Dockerfile. Понятно, что пользователь перед этим должен быть создан.
    \n\tШаблоны ввода:
    \n\t\t• <имя>"
    PlaceHolder: "<имя>"
  -
    Name: "WORKDIR"
    Description: "\tУстанавливает рабочий каталог для всех инструкций RUN, CMD, ENTRYPOINT, COPY и ADD которые будут выполнены в Dockerfile. Если WORKDIR не задана, то она будет создана даже если в Dockerfile нет ни одной инструкции для которой это необходимо. Инструкция может быть использована несколько раз в одном Dockerfile. Если указывается относительный путь, он будет определен относительно предыдущего значения WORKDIR.
    \n\tШаблоны ввода:
    \n\t\t• /<рабочий каталог> (если не пишется \"/\", то WORKDIR поменяется относительно старого WORKDIR, в первом WORKDIR и при задании абсолютного пути использовать \"/\" перед названием каталога)
    Инструкция WORKDIR может использовать переменные окружения заданные через ENV (${ИМЯ})."
    IsMany: true
    PlaceHolder: "/<рабочий каталог>"
  -
    Name: "ARG"
    Description: "Задает переменные которые пользователь передает сборщику образа, аргументы предаваемые при инициализации сборки контейнера (docker build). 
    \n\tШаблоны ввода:
    \n\t\t• <имя>=<значение по умолчанию> (задается значение по умолчанию, которое будет использовать сборщик, если ничего не передали, предпочтительно)
    \n\t\t• <имя> (просто инициалзация переменной)
    \n\tНе рекомендуется использовать в переменных сборки секретные ключи например от github, учетные данные пользователя и т. д. Переменные окружения заданные с помощью ENV всегда заменяют переменные с тем же именем заданные инструкцией ARG. Docker имеет набор предустановленных переменных ARG которые вы можете задавать без предварительной инструкции ARG в Dockerfile (гуглите сами). Переменные ARG не сохраняются в собранном образе в отличае от ENV переменных."
    IsMany: true
    PlaceHolder: "<имя>=<значение по умолчанию>"
  -
    Name: "ONBUILD"
    Description: "\tДобавляет к образу триггерную инструкцию, которая выполняется в последнюю очередь если образ используется в качестве базового для другой сборки. Триггер будет выполнен в дочернем контексте сборки, так если бы инструкция была вставлена сразу после инструкции FROM дочернего Dockerfile. Это полезно если вы собираете образ который будет использоваться в качестве базового для сборки другого образа, например вы можете изменить переменные окружения или сделать демон конфигурация которого может быть изменена пользователем.
    \n\tШаблоны ввода:
    \n\t\t• <имя инструкции> <что обычно после данной инструкции> (например RUN ls)
    \n\tЦепи инструкций ONBUILD ONBUILD и ONBUILD FROM не допускаются. Инструкция внутри ONBUILD не оказывает влияния на текущую сборку. В дочернем образе ONBUILD функционирует как часть обработки инструкции FROM, сборщик ищет ONBUILD триггеры и выполняет их в том же порядке в котором они были добавлены. Если один из триггеров вызывает ошибку, инструкция FROM обрывается и вызывает ошибку сборки. Если все триггеры отработали, инструкция FROM завершается и сборка продолжается как обычно, а также дочерние образы не унаследуют триггеры прародителей. Не создает новый слой, так что дкблируем инструкции."
    IsMany: true
    PlaceHolder: "<инструкция>"
  -
    Name: "STOPSIGNAL"
    Description: "\tУстанавливает сигнал системного вызова, который будет отправлен для завершения контейнера. Сигнал может быть натуральным числом, которое соответствует позиции в таблице системных вызовов ядра, например 9 или именем сигнала в формате SIGNAME, например SIGKILL. Мало когда используется по-моему.
    \n\tШаблоны ввода:
    \n\t\t• <натруральное число> 
    \n\t\t• <SIGNAME> (заглавными буквами)"
    PlaceHolder: "<сигнал>"
  -
    Name: "HELATHCHECK"
    Description: "\tУказывает Docker как проверить работает ли контейнер. Данная функция может помочь в выявлении ситуаций когда веб-сервер вошел в бесконечный цикл и не принимает соединения, в то время как его процесс все еще работает.
    \n\tШаблоны ввода:
    \n\t\t• [опции...] <CMD команда> (слово CMD обязательно, опции: --interval=<время между проверками> (по умолчанию: 30s); --timeout=<время, после которого проверка является не удачной> (по умолчанию: 30s); --retries=<допустимое количество неудачных проверок> (по умолчанию: 3))
    \n\t\t• <CMD команда>
    \n\t\t• NONE (явно указываем, что проверка не нужна)
    \n\tКогда у контейнера задана проверка на работоспособность, он имеет дополнительный статус состояния. Этот статус изначально равен starting. Всякий раз когда проверка состояния проходит успешно, он становится равен healthy (вне зависимости от предыдущего состояния). После определенного числа неудачных проверок статус изменяется на unhealthy. Дальше уже проблема оркестратора."
    PlaceHolder: "[опции...] <CMD команда>"
  -
    Name: "SHELL"
    Description: "\tПозволяет заменить стандартную оболочку для выполнения команд на пользовательскую. Оболочкой по умолчанию в Linux является [\"/bin/sh\", \"-c\"], а в Windows [\"cmd\", \"/S\", \"/C\"]. Может использоваться несколько раз, заменяя предыдущую инструкцию SHELL, и влияя на все последующие инструкции(RUN, CMD и ENTRYPOINT). 
    \n\tШаблоны ввода:
    \n\t\t• [\"<исполняемый файл>\", \"<параметры>\"...]
    \n\tИнструкция SHELL в частности полезна в Windows где есть две совершенно разных оболочки: cmd и powershell, а также альтернативные включая sh и Linux для переключения на альтернативные оболочки вроде zsh, csh, tcsh и т.д."
    IsMany: true
    PlaceHolder: "[\"<исполняемый файл>\", \"<параметры>\"...]"